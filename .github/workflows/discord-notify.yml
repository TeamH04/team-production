name: Notify Discord

on:
  issues:
    types: [assigned] # ã‚¢ã‚µã‚¤ãƒ³ã•ã‚ŒãŸæ™‚/å¤‰æ›´ã•ã‚ŒãŸæ™‚
  pull_request:
    types: [review_requested, ready_for_review, closed, reopened] # ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¾é ¼/ãƒžãƒ¼ã‚¸ç­‰
  pull_request_review:
    types: [submitted] # ãƒ¬ãƒ“ãƒ¥ãƒ¼åˆ°ç€

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  notify-discord:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Notify
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            const fs = require('fs');

            // --- å…±é€š: ãƒžãƒƒãƒ—èª­è¾¼ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ---
            let map = {};
            try {
              map = JSON.parse(fs.readFileSync('.github/discord-map.json', 'utf8'));
            } catch (e) {
              core.warning('discord-map.json ãŒèª­ã‚ã¾ã›ã‚“ã€‚ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ã§é€ã‚Šã¾ã™ã€‚');
            }

            const mentionOf = (login) => {
              const id = map[login];
              return id ? `<@${id}>` : `@${login}`;
            };

            const uniq = (arr) => [...new Set(arr)].filter(Boolean);

            const post = async (content) => {
              const url = process.env.DISCORD_WEBHOOK_URL;
              if (!url) throw new Error('DISCORD_WEBHOOK_URL ãŒæœªè¨­å®šã§ã™');
              const body = { content };
              const res = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body),
              });
              if (!res.ok) {
                core.setFailed(`Discordé€ä¿¡å¤±æ•—: ${res.status} ${await res.text()}`);
              }
            };

            const ev = context.eventName;
            const action = context.payload.action;

            // ---- ã‚±ãƒ¼ã‚¹åˆ†å² ----
            if (ev === 'issues') {
              // ä»•æ§˜: Issueã‚’ç«‹ã¦ãŸæ™‚ã« assign ã—ãŸäººã¸ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
              // å¯¾è±¡: openedï¼ˆåˆå›žã«assigneesãŒä»˜ã„ã¦ã„ã‚‹å ´åˆï¼‰ã¨ assignedï¼ˆå¾Œã‹ã‚‰ä»˜ä¸Žï¼‰
              if (action === 'opened' || action === 'assigned') {
                const issue = context.payload.issue;
                const repo = context.repo.repo;
                const owner = context.repo.owner;
                const url = issue.html_url;

                const added = context.payload.assignee?.login;
                if (!added) return;
                const mentions = mentionOf(added);

                const title = issue.title;

                const msg = [
                  `ðŸ“ **Issue Assigned** in \`${owner}/${repo}\``,
                  `**${title}**`,
                  `${mentions}`,
                  `${url}`
                ].join('\n');

                await post(msg);
              }
            }

            else if (ev === 'pull_request') {
              const pr = context.payload.pull_request;
              const owner = context.repo.owner;
              const repo = context.repo.repo;

              if (action === 'review_requested') {
                // ä»•æ§˜: PRã‚’ç«‹ã¦ãŸæ™‚ã« reviewer ã«ã—ãŸäººã¸ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
                // â€»ã€Œreview_requestedã€ã¯ä½œæˆæ™‚ï¼å¾Œã‹ã‚‰ä¾é ¼ã—ãŸæ™‚ã©ã¡ã‚‰ã‚‚ç™ºç«
                const reqReviewer = context.payload.requested_reviewer?.login;
                const reqTeam = context.payload.requested_team?.name;
                if (reqReviewer && reqReviewer.toLowerCase().includes('copilot')) return;
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼å€‹åˆ¥ã®ã¿ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ï¼ˆãƒãƒ¼ãƒ ã¯ä»»æ„ã§ãƒ­ãƒ¼ãƒ«ã«ç½®æ›ã—ã¦ã‚‚OKï¼‰
                if (reqReviewer) {
                  const msg = [
                    `ðŸ‘€ **Review Requested** in \`${owner}/${repo}\``,
                    `**${pr.title}** by @${pr.user.login}`,
                    `${mentionOf(reqReviewer)}`,
                    `${pr.html_url}`
                  ].join('\n');
                  await post(msg);
                }
              }

              else if (action === 'opened' || action === 'ready_for_review' || action === 'reopened') {
                // PRä½œæˆæ™‚ï¼Draftè§£é™¤æ™‚: reviewerãŒåŒæ™‚æŒ‡å®šã•ã‚Œã¦ã„ãŸã‚‰é€šçŸ¥ï¼ˆä»»æ„ï¼‰
                const reviewers = (pr.requested_reviewers || []).map(u => u.login);
                if (reviewers.length > 0) {
                  const msg = [
                    `ðŸ†• **PR Opened** in \`${owner}/${repo}\``,
                    `**${pr.title}** by @${pr.user.login}`,
                    `Reviewers: ${uniq(reviewers).map(mentionOf).join(' ')}`,
                    `${pr.html_url}`
                  ].join('\n');
                  await post(msg);
                }
              }

              else if (action === 'closed' && pr.merged) {
                // ä»•æ§˜: PRãŒmergeã•ã‚ŒãŸã¨ãã«é€šçŸ¥
                const msg = [
                  `âœ… **PR Merged** in \`${owner}/${repo}\``,
                  `**${pr.title}** by @${pr.user.login}`,
                  `${pr.html_url}`
                ].join('\n');
                await post(msg);
              }
            }

            else if (ev === 'pull_request_review') {
              // ä»•æ§˜: PRã«reviewãŒæ¥ãŸã¨ãã«ã€PRä½œæˆè€…ã¸é€šçŸ¥
              if (action === 'submitted') {
                const pr = context.payload.pull_request;
                const review = context.payload.review;
                const owner = context.repo.owner;
                const repo = context.repo.repo;

                const state = (review.state || '').toUpperCase(); // APPROVED / CHANGES_REQUESTED / COMMENTED
                const reviewer = review.user?.login || '(unknown)';
                const author = pr.user?.login || '(unknown)';
                // è‡ªåˆ†ã®PRã‚’è‡ªåˆ†ã§ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ãŸå ´åˆã¯é€šçŸ¥ã—ãªã„ï¼ˆä»»æ„ï¼‰
                if (author && reviewer && author === reviewer) return;
                // PRä½œæˆè€…ã‚’å¿…ãšãƒ¡ãƒ³ã‚·ãƒ§ãƒ³
                const authorMention = mentionOf(author);
                // ãƒ¬ãƒ“ãƒ¥ãƒ¼æœ¬æ–‡ã‚’è»½ãè¦ç´„ï¼ˆé•·ã™ãŽã‚‹ã¨WebhookãŒå¼¾ãã®ã§å…ˆé ­ã ã‘ï¼‰
                const body = (review.body || '').trim();
                const snippet = body ? (body.length > 200 ? body.slice(0, 200) + 'â€¦' : body) : '';
                const msgLines = [
                  `ðŸ’¬ **PR Review (${state})** in \`${owner}/${repo}\``,
                  `**${pr.title}**`,
                  `Reviewer: ${mentionOf(reviewer)}`,
                  `${authorMention}`, // â† ã“ã“ã§PRä½œæˆè€…ã¸é€šçŸ¥
                  `${pr.html_url}#pullrequestreview-${review.id}`
                ];
                if (snippet) {
                  msgLines.push('\n> ' + snippet.replace(/\n/g, '\n> '));
                }

                await post(msgLines.join('\n'));
              }
            }
